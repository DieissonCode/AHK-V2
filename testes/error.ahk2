#Requires AutoHotkey v2.0

;~ https://github.com/jixiuf/my_autohotkey_scripts/tree/master/ahk_scripts
;;emacs-key-sequence.ahk --   binding GNU/Emacs like key

;; about how to use this emacs-key-sequence.ahk
;; 1. include emacs-key-sequence.ahk in you ahk files
;; like this :
;; #Include emacs-key-sequence.ahk
;; 2. define a Object() ,a map
;;   and insert("keys" ,"functionNameYouWantToCallWhenYouPresskeys")
;; for example ,
;; map:=Object()
;; map.insert("^x^f","msg1")
;; map.insert("^x^e^e","msg2")
;; map.insert("^xvv","msg3")
;;
;; 3 ,bind  the root key prefix to the root key prefix
;; for example
;; $^x::
;;      map:=Object()
;;      map.insert("^x^f","msg1")
;;      map.insert("^x^e^e","msg2")
;;      map.insert("^xvv","msg3")
;;    prefixKey("^x",map)
;; return
;; $^d::
;;   map:=Object()
;;      map.insert("^d^f","msg1")
;;      map.insert("^d^e^e","msg2")
;;      map.insert("^dvv","msg3")
;;    prefixKey("^d",map)
;; the "$" ,must be used

;;4 define functions that will be called the some key is pressed
;; msg1(){
;;   MsgBox ,this is function msg1(),will be called when you press ^x^f in this example
;; }
;; msg2(){
;;   MsgBox ,this is function msg2(),will be called when you press ^x^e^e in this example
;; }
;; msg3(){
;;   MsgBox ,this is function msg3(),will be called when you press ^xvv in this example
;; }
Persistent
SetKeyDelay(0)

prefixKey(prefix ,keyFuncMap){
seq:=prefix
Loop
{
; {LCsontrol}{RControl}{LAlt}{RAlt}{LShift}{RShift}{LWin}{RWin}{AppsKey}{F1}{F2}{F3}{F4}{F5}{F6}{F7}{F8}{F9}{F10}{F11}{F12}{Left}{Right}{Up}{Down}{Home}{End}{PgUp}{PgDn}{Del}{Ins}{BS}{Capslock}{Numlock}{PrintScreen}{Pause}{Escape}
ihinput := InputHook("L1","{Escape}{LControl}{RControl}{LAlt}{RAlt}{LShift}{RShift}{LWin}{RWin}abcdefghijklmnopqrstuvwxyz1234567890{F1}{F2}{F3}{F4}{F5}{F6}{F7}{F8}{F9}{F10}{F11}{F12}{Left}{Right}{Up}{Down}{Home}{End}{PgUp}{PgDn}{Del}{Ins}{BS}{Capslock}{Numlock}{PrintScreen}{Pause}{Escape}"), ihinput.Start(), ihinput.Wait(), input := ihinput.Input
;L1：长度限制为1,当文本达到这个长度时, 输入被终止
    if (ihinput.EndReason = "EndKey:Escape")
    {
     seq := "prefix"
    }
if (ihinput.EndReason = "EndKey:LControl")
{
continue
}
if (ihinput.EndReason = "EndKey:RControl")
{
continue
}
if (ihinput.EndReason = "EndKey:LWin")
{
continue
}
if (ihinput.EndReason = "EndKey:RWin")
{
continue
}
if (ihinput.EndReason = "EndKey:LAlt")
{
continue
}
if (ihinput.EndReason = "EndKey:RAlt")
{
continue
}
if (ihinput.EndReason = "EndKey:LShift")
{
continue
}
if (ihinput.EndReason = "EndKey:RShift")
{
continue
}
if (ihinput.EndReason = "EndKey:a")
{
input := "a"
}
if (ihinput.EndReason = "EndKey:b")
{
input := "b"
}
if (ihinput.EndReason = "EndKey:c")
{
input := "c"
}
if (ihinput.EndReason = "EndKey:d")
{
input := "d"
}
if (ihinput.EndReason = "EndKey:e")
{
input := "e"
}
if (ihinput.EndReason = "EndKey:f")
{
input := "f"
}
if (ihinput.EndReason = "EndKey:g")
{
input := "g"
}
if (ihinput.EndReason = "EndKey:h")
{
input := "h"
}
if (ihinput.EndReason = "EndKey:i")
{
input := "i"
}
if (ihinput.EndReason = "EndKey:j")
{
input := "j"
}
if (ihinput.EndReason = "EndKey:k")
{
input := "k"
}
if (ihinput.EndReason = "EndKey:l")
{
input := "l"
}
if (ihinput.EndReason = "EndKey:m")
{
input := "m"
}
if (ihinput.EndReason = "EndKey:n")
{
input := "n"
}
if (ihinput.EndReason = "EndKey:o")
{
input := "o"
}
if (ihinput.EndReason = "EndKey:p")
{
input := "p"
}
if (ihinput.EndReason = "EndKey:q")
{
input := "q"
}
if (ihinput.EndReason = "EndKey:r")
{
input := "r"
}
if (ihinput.EndReason = "EndKey:s")
{
input := "s"
}
if (ihinput.EndReason = "EndKey:t")
{
input := "t"
}
if (ihinput.EndReason = "EndKey:u")
{
input := "u"
}
if (ihinput.EndReason = "EndKey:v")
{
input := "v"
}
if (ihinput.EndReason = "EndKey:w")
{
input := "w"
}
if (ihinput.EndReason = "EndKey:x")
{
input := "x"
}
if (ihinput.EndReason = "EndKey:y")
{
input := "y"
}
if (ihinput.EndReason = "EndKey:z")
{
input := "z"
}
if (ihinput.EndReason = "EndKey:1")
{
input := "1"
}
if (ihinput.EndReason = "EndKey:2")
{
input := "2"
}
if (ihinput.EndReason = "EndKey:3")
{
input := "3"
}
if (ihinput.EndReason = "EndKey:4")
{
input := "4"
}
if (ihinput.EndReason = "EndKey:5")
{
input := "5"
}
if (ihinput.EndReason = "EndKey:6")
{
input := "6"
}
if (ihinput.EndReason = "EndKey:7")
{
input := "7"
}
if (ihinput.EndReason = "EndKey:8")
{
input := "8"
}
if (ihinput.EndReason = "EndKey:9")
{
input := "9"
}
if (ihinput.EndReason = "EndKey:0")
{
input := "0"
}
if (ihinput.EndReason = "EndKey:F1")
{
input := "{F1}"
}
if (ihinput.EndReason = "EndKey:F2")
{
input := "{F2}"
}
if (ihinput.EndReason = "EndKey:F3")
{
input := "{F3}"
}
if (ihinput.EndReason = "EndKey:F4")
{
input := "{F4}"
}
if (ihinput.EndReason = "EndKey:F5")
{
input := "{F5}"
}
if (ihinput.EndReason = "EndKey:F6")
{
input := "{F6}"
}
if (ihinput.EndReason = "EndKey:F7")
{
input := "{F7}"
}
if (ihinput.EndReason = "EndKey:F8")
{
input := "{F8}"
}
if (ihinput.EndReason = "EndKey:F9")
{
input := "{F9}"
}
if (ihinput.EndReason = "EndKey:F10")
{
input := "{F10}"
}
if (ihinput.EndReason = "EndKey:F11")
{
input := "{F11}"
}
if (ihinput.EndReason = "EndKey:F12")
{
input := "{F12}"
}
if (ihinput.EndReason = "EndKey:Down")
{
input := "{Down}"
}
if (ihinput.EndReason = "EndKey:Left")
{
input := "{Left}"
}
if (ihinput.EndReason = "EndKey:Right")
{
input := "{Right}"
}
if (ihinput.EndReason = "EndKey:Up")
{
input := "{Up}"
}
if (ihinput.EndReason = "EndKey:Home")
{
input := "{Home}"
}
if (ihinput.EndReason = "EndKey:End")
{
input := "{End}"
}
if (ihinput.EndReason = "EndKey:PageUp")
{
input := "{PageUp}"
}
if (ihinput.EndReason = "EndKey:PageDown")
{
input := "{PageDown}"
}
if (ihinput.EndReason = "EndKey:Del")
{
input := "{Del}"
}
if (ihinput.EndReason = "EndKey:Ins")
{
input := "{Ins}"
}
if (ihinput.EndReason = "EndKey:BS")
{
input := "{BS}"
}
if (ihinput.EndReason = "EndKey:Capslock")
{
input := "{Capslock}"
}
if (ihinput.EndReason = "EndKey:Numlock")
{
input := "{Numlock}"
}
if (ihinput.EndReason = "EndKey:PrintScreen")
{
input := "{PrintScreen}"
}
if (ihinput.EndReason = "EndKey:Pause")
{
input := "{Pause}"
}
if (ihinput.EndReason = "EndKey:Escape")
{
input := "{Escape}"
}

 tmpStr := ""
   if (GetKeyState("RWin")=1 ||GetKeyState("LWin")=1){
     tmpStr := "#"
   }
  if (GetKeyState("RControl")=1 ||GetKeyState("LControl")=1 ){
      tmpStr := tmpStr . "^"
   }
  if (GetKeyState("RAlt")=1 ||GetKeyState("LAlt")=1 ){
      tmpStr := tmpStr . "!"
   }
  if (GetKeyState("RShift")=1 ||GetKeyState("LShift")=1 ){
      tmpStr := tmpStr . "+"
   }
   tmpStr := tmpStr . "" . input
       if (tmpStr = "^g")  ;;Ctrl+g ,cancel ,
           break
      seq := seq . "" . tmpStr
     ;; ToolTip,%seq%
      funcName:= keyFuncMap[seq]
           if (funcName != "")
            {
              callFuncByName(funcName)
              break
            }else{
              containPrefix := ""
              For k, v in keyFuncMap
              {
                pos := InStr(k, seq) - 1
                if (pos = 0)  ;;if k starts with seq
                {
                 containPrefix:=true
                 break
                 }
              }
              ;;if key Prefix you press don't exists in keyFuncMap ,then
              ;;send it to system
              ;;suppose the map is {"^xvd" "function1"
              ;;                    "^xc" "function2"}
              ;; and you have pressed "^xd" , there isn't a key equas "^xd"
              ;; so no function would be called
              ;; and "^xd" will be send to system
              if (containPrefix = "")
              {
;;              Tooltip ,%seq%
                  SendInput(seq)
                  break
              }else{
                 continue
              }
            }
}

}
;;end of func prefixKey(..)

;;param string , funcName is a function
;;without paramters
callFuncByName(funcName){
  fun1:=CallbackCreate(%funcName%, "F", 0)
  DllCall(fun1)

}
;; key:=map["^xf"]
;; callFuncByName(key)
